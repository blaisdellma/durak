// // Only here for reference
// // split out into seperate files
// 
// use std::net::{TcpStream,TcpListener};
// use std::io::{Write,BufWriter,Read,BufRead,BufReader};

// use tracing::{info};
// use serde::{Serialize,Deserialize};

// use durak::{*,card::*,toplaystate::*};

// pub struct NetServerDurakPlayer {
//     pub id: u64,
//     stream: TcpStream,
// }

// impl NetServerDurakPlayer {
//     fn new(stream: TcpStream) -> Self {
//         NetServerDurakPlayer {
//             id: 0,
//             stream: stream,
//         }
//     }

//     fn query_client<A: Serialize, B: for<'b> Deserialize<'b>>(&mut self, sig: &str, data: &A) -> DurakResult<B> {
//         let json = serde_json::to_string(data)?;
//         let content = json.as_bytes();
//         let mut stream = BufWriter::new(&mut self.stream);
//         stream.write(sig.as_bytes())?;
//         stream.write(content)?;
//         stream.flush()?;
//         drop(stream);
//         let mut stream = BufReader::new(&mut self.stream);
//         let mut data = String::new();
//         let _ = stream.read_line(&mut data)?;
//         let ret: B = serde_json::from_str(&data)?;
//         Ok(ret)
//     }

// }

// impl DurakPlayer for NetServerDurakPlayer {
//     fn attack(&mut self, state: &ToPlayState) -> DurakResult<Option<Card>> {
//         self.query_client("A\n",state)
//     }

//     fn defend(&mut self, state: &ToPlayState) -> DurakResult<Option<Card>> {
//         self.query_client("D\n",state)
//     }

//     fn pile_on(&mut self, state: &ToPlayState) -> DurakResult<Vec<Card>> {
//         self.query_client("P\n",state)
//     }

//     fn observe_move(&mut self, state: &ToPlayState) -> DurakResult<()> {
//         self.query_client("O\n",state)
//     }

//     fn get_id(&mut self, player_info: &Vec<PlayerInfo>) -> DurakResult<u64> {
//         self.query_client("I\n",player_info)
//     }

//     fn won(&mut self) -> DurakResult<()> {
//         let mut stream = BufWriter::new(&mut self.stream);
//         stream.write("W\n".as_bytes())?;
//         stream.flush()?;
//         Ok(())
//     }

//     fn lost(&mut self) -> DurakResult<()> {
//         let mut stream = BufWriter::new(&mut self.stream);
//         stream.write("L\n".as_bytes())?;
//         stream.flush()?;
//         Ok(())
//     }
// }

// pub struct DurakServer {
//     listener: TcpListener,
//     players: Vec<NetServerDurakPlayer>,
// }

// impl DurakServer {
//     pub fn new() -> DurakResult<Self> {
//         Ok(DurakServer {
//             listener: TcpListener::bind("127.0.0.1:8080")?,
//             players: Vec::new(),
//         })
//     }

//     pub fn wait_connection(&mut self) -> DurakResult<()> {
//         match self.listener.accept() {
//             Ok((socket,addr)) => {
//                 info!("Connection at {}",addr);
//                 self.players.push(NetServerDurakPlayer::new(socket));
//             },
//             Err(e) => return Err(e.into()),
//         }
//         Ok(())
//     }

//     pub fn get_players(self) -> DurakResult<Vec<NetServerDurakPlayer>> {
//         Ok(self.players)
//     }
// }

// pub struct NetClientDurakPlayer<T: DurakPlayer> {
//     engine: T,
//     stream: TcpStream,
// }

// impl<T: DurakPlayer> NetClientDurakPlayer<T> {
//     fn process_query<A: for<'a> Deserialize<'a>,B: Serialize,F: Fn(&mut Self,&A)->DurakResult<B>>(&mut self, func: F) -> DurakResult<()> {
//         let mut stream = BufReader::new(&mut self.stream);
//         let mut buf = Vec::new();
//         stream.read_to_end(&mut buf)?;
//         let string = String::from_utf8(buf)?;
//         let data = serde_json::from_str(&string)?;
//         let ret = func(self,&data)?;
//         let content = serde_json::to_string(&ret)?;
//         let mut stream = BufWriter::new(&mut self.stream);
//         stream.write(content.as_bytes())?;
//         stream.flush()?;
//         Ok(())
//     }
// }

// impl<T: DurakPlayer> NetClientDurakPlayer<T> {
//     pub fn new(durak_player: T) -> DurakResult<Self> {
//         Ok(NetClientDurakPlayer {
//             engine: durak_player,
//             stream: TcpStream::connect("127.0.0.1:8080")?,
//         })
//     }

//     pub fn wait(&mut self) -> DurakResult<usize> {
//         let mut stream = BufReader::new(&mut self.stream);
//         let mut data = String::new();
//         let _ = stream.read_line(&mut data)?;
//         match data.get(0..1) {
//             None => {},
//             Some("A") => {
//                 self.process_query(|player,state| player.engine.attack(state))?;
//             },
//             Some("D") => {
//                 self.process_query(|player,state| player.engine.defend(state))?;
//             },
//             Some("P") => {
//                 self.process_query(|player,state| player.engine.pile_on(state))?;
//             },
//             Some("O") => {
//                 self.process_query(|player,state| player.engine.observe_move(state))?;
//             },
//             Some("I") => {
//                 self.process_query(|player,player_info| player.engine.get_id(player_info))?;
//             },
//             Some("W") => {
//                 self.engine.won()?;
//                 return Ok(1);
//             },
//             Some("L") => {
//                 self.engine.lost()?;
//                 return Ok(2);
//             },
//             _ => {},
//         }
//         Ok(0)
//     }
// }

